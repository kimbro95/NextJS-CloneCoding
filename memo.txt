########################
### 3.0 NextJS Setup ###
########################
-NextJS 프로젝트 초기화
npx create-next-app@latest --typescript (https://nextjs.org/docs/getting-started)

NextJS, React 최신(rc) 버전 설치
npm i next@latest react@rc react-dom@rc

🚨 에러
TypeError: Cannot set properties of undefined (setting 'reactRoot')

next.config.js 파일에 
experimental: {reactRoot: true} 추가하여 버전다운그레이드 없이 실행하기

소프트웨어 배포 생명 주기
1.Alpha : 소프트웨어 테스트를 시작하는 첫 단계
2.Beta : 알파의 뒤를 잇는 소프트웨어 개발 단계
3.RC(Release Candidate) : 최종 릴리즈 후보    👈 현재 프로젝트의 react 버전
4.RTM : 완성된 버전


#############################
### 3.1 TailwindCSS Setup ###
#############################
-Tawilwind CSS 설치 및 초기화
npm i -D tailwindcss postcss autoprefixer
npx tailwindcss init -p ( postcss.config.js, tailwindcss.config.js 파일 생성)
https://tailwindcss.com/docs/installation/using-postcss

globals.css
기존 내용을 전부 삭제하고
@tailwind base;
@tailwind components;
@tailwind utilities;
추가


########################
### 4.0 Introduction ###
########################
-TailwindCSS
클래스로 가득 찬 유틸리티 최초의 CSS프레임워크

-Tailwind CSS IntelliSense (vscode 확장 프로그램)
클래스명 자동완성 기능
https://tailwindcss.com
https://tailwind.build/classes - 클래스 검색 사이트


#########################################################
### 4.1 Test Drive part One - 4.3 Test Drive part Two ###
#########################################################
-TailwindCSS
ex) px-1
뒤에 숫자가 붙으면 숫자(1)x 4 4px이 적용되고 rem은 1 / 4인 0.25rem으로 적용된다
TailwindCSS는 rem 단위라서 반응형 웹을 만들기에도 편한다.

클래스명에서 x는 left, right의 x축 y는 top, bottom의 y축을 의미한다.
ex) px-1 : padding-left, padding-right
    py-1 : padding-top, padding-bottom


#####################
### 4.4 Modifiers ###
#####################
-TailwindCSS Modifiers List
hover(&:hover)
focus(&:focus)
active(&:active)
first(&:first-child)
disabled(&:disabled)
sm(@media (min-width: 640px))
md(@media (mid-width: 768px))
lg(@media (min-width: 1024px))
dark(@media (perfers-color-scheme: dark))
참조
https://tailwindcss.com/docs/hover-focus-and-other-states#quick-reference


#######################
### 4.5 Transitions ###
#######################
-Ring Width
상자 그림자가 있는 윤곽선을 만들기 위한 유틸리티
ring-{width}를 사용하여 특정 두께의 solid box-shadow를 요소에 적용
링은 기본적으로 반투명한 파란색으로 많은 시스템의 기본 포커스 링 스타일과 유사
ex) <button> className="...ring-offset-2 ring-2"</button>
    <button> className="...focus: ring-2"</button>
    <div className="...ring-2 hover: ring-4"></div>
    <div className="...ring-2 md: ring-4"></div>
참조
https://tailwindcss.com/docs/ring-width


-Ring Color
외곽선 링의 색상을 설정하는 유틸리티
ring-{color}를 사용하여 외곽선 링의 색상을 설정
ex) <button className="...ring-2 ring-blue-500"></button>
    <button className="...ring-2 ring-blue-500/50></button>
참조
https://tailwindcss.com/docs/ring-color


###############################
### 4.6 Modifiers for Lists ###
###############################
first(:first-child) 자식요소 첫번째에 스타일을 지정
last(:last-child) 자식요소 마지막번째에 스타일을 지정
only(:only-child) 자식요소가 한 개일 경우 스타일 지정
odd (:nth-child(odd)) 자식요소의 순서가 홀수일 때 스타일 지정
even (:nth-child(even)) 자식요소의 순서가 짝수일 때스타일 지정
참조
https://tailwindcss.com/docs/hover-focus-and-other-states#first

-empty (:empty)
empth 수정자를 사용하여 콘텐츠가 없는 경우 스타일 지정
ex) {["1", "2", "3", ""].map((v, i) => (
        <li key={i} className="bg-green-400 py-1 empty:hidden">
            {v}
        </li>
    ))}
배열에 3번째 다음이 빈값이기 때문에 empty:hidden을 준다
empty: hidden => display:none과 같다.
참조
https://tailwindcss.com/docs/hover-focus-and-other-states#empty


###############################
### 4.7 Modifiers for Forms ###
###############################
-group
상위 상태를 기반으로 한 스타일 지정 (group-{modifier})
일부 부모 요소의 상태를 기반으로 요소의 스타일을 지정해야 하는 경우 부모를 그룹으로 클래스를 표시하고
group-hover와 같은 group-* 수정자를 사용하여 대상 요소의 스타일을 지정한다.
group-focus, group-active, group-odd와 같은 모든 유사 클래스 수정자와 함께 작동한다.
참조
https://tailwindcss.com/docs/hover-focus-and-other-states#styling-based-on-parent-state

-peer
형제 상태를 기반으로 한 스타일 지정 (peer-{modifier})
형제 요소의 상태를 기반으로 요소의 스타일을 지정해야 하는 경우 형제를 피어 클래스로 표히사고
peer-invaild 같은 peer-* 수정자를 사용하여 대상 요소의 스타일을 지정합니다.
peer-focus, peer-required, peer-disabled와 같은 모든 유사 클래스 수정자와 함께 작동한다.
참조
https://tailwindcss.com/docs/hover-focus-and-other-states#styling-based-on-sibling-state


##########################
### 4.8 More Modifiers ###
##########################
-details
HTML 요소이다 details는 요소가 "open" 상태일 때만 내부 정보를 보여주고 정보 공개 위젯을 생성한다.
요약이나 레이블은 summary요소를 통해 제공할 수 있습니다.
정보공개 위젯은 보통 레이블 옆의 작은 삼각형이 돌아가면서 open/close상태로 나뉜다.
details요소의 첫 번째 자식이 summary요소라면 summary의 콘텐츠를 위젯의 레이블로 사용한다.
ex) <details>
        <summary>Hello Details</summary>
        <span>Details</span>
    </details>
참조
https://developer.mozilla.org/ko/docs/Web/HTML/Element/details

-file
파일 수정자를 사용하여 파일 입력의 버튼 스타일 지정 (file-{modifier})
ex) file:bg-blue-400 file:py-4
참조
https://tailwindcss.com/docs/hover-focus-and-other-states?email=george%40krugerindustrial&password=Bosco#file-input-buttons


#####################################################################
### 4.9 Responsive Modifiers - 4.10 Responsive Modifiers part Two ###
#####################################################################
-Responsive Design
화면 크기를 기반으로 한 스타일 지정 ( sm, md, lg, xl, 2xl )
sm: 최소길이가 640px 일 때
md: 최소길이가 768px 일 때
lg: 최소길이가 1024px 일 때
xl: 최소길이가 1280px 일 때
2xl: 최소길이가 1536px 일 때
참조
https://tailwindcss.com/docs/responsive-design#overview

-Viewport orientation
portrait: 가로 모드 ex.portrait:bg-blue-400
landscape: 세로 모드 ex.landscape: bg-orange-400
참조
https://tailwindcss.com/docs/hover-focus-and-other-states#viewport-orientation



######################
### 4.11 Dark Mode ###
######################
-Dark Mode
Tailwind에는 dark모드가 활성화되어 있을 때 사이트 스타이을 다르게 지정할 수 있는 dark변형이 포함되어있다.
현재 사용 중인 운영 체제 설정에 따라 dark가 자동으로 적용된다.
ex) dark:bg-gray-500
참조
https://tailwindcss.com/docs/dark-mode

수동 다크모드
운영 체제 기본 설정에 의조하는 대신 수동으로 다크 모드 전환을 지원하려면
tailwind.config.js에서 다크모드 설정을 media 대신 class 를 사용해야한다.

tailwind.config.js
// 클래스를 기준으로 다크모드 적용 ( 최상위 부모에 dark클래스를 지정해줘야한다. ex.<html className="dark">, <body className="dark"> )
module.exports = {
    ...
    darkMode: "class",
}

// @media(prefers-color-scheme)를 기준으로 다크모드 적용( 기본 값 )
module.export = {
    ...
    darkMode: "media",
}
참조
https://tailwindcss.com/docs/dark-mode#toggling-dark-mode-manually



##################################
### 4.12 Just In Time Compiler ###
##################################
-Migrating to the JIT engine
TailwindCSS 엔진
v3.0 이전: 거대한 CSS파일을 생성하고, 그 파일에 이미 정의해놓은 클래스들을 가져와 사용하는 방식
이 경우에 코드 길이가 길고 클래스로 가득찬 파일을 가져와서 개발단계에 사용하기 때문에 매우 무겁고
배보 전 purge를 해줘야하는 번거로움이있다.

v3.0 이후: 사용자가 사용하는 스타일들만 그때 그때 생성해서 사용하는 방식
여러 클래스들을 조합해서 사용할 수 있고, 매우 가볍고, 배포 전 purge를 해주지 않아도된다.
참조
https://tailwindcss.com/docs/upgrade-guide#migrating-to-the-jit-engine



#############################################
### 5.1 Auth part One - 5.2 Auth part Two ###
#############################################
-Plugins
재사용 가능한 타사 플러그인 Tailwind 확장 개요 플러그인을 사용하려면
CSS대신 JavaScripte를 사용하여 사용자의 스타일시트에 삽입할 Tawilwind 에 대한 스타일을 동록 할 수 있다.
참조
https://tailwindcss.com/docs/plugins

-@tailwindcss/forms
form 요소를 유틸리티로 쉽게 재정의할 수 있도록 하는 form 스타일에 대한 기본 재설정을 제공하는 플러그
@tailwindcss/forms 플러그인은 유틸리티 클래스를 사용하여 form 요소의 스타일을 쉽게 지정할 수 있도록 하는 독창적인
form reset layer를 추가한다.
설치
npm i -D @tailwindcss/forms

⭐플러그인은 설치 후 tailwind.config.js에 plugins에 추가해야한다.⭐
// tailwind.config.js
module.exports = {
    theme:{
        ...
    },
    plugins:[require("@tailwindcss/forms")],
}
plugins안에 require(플러그인명)을 추가한다.
참조
https://tailwindcss.com/docs/plugins#forms



#######################
### 5.3 Home Screen ###
#######################
-Heroicons
TailwindCSS로부터 만들어진 손으로 만든 SVG아이콘
참조
https://heroicons.com/

-Space Between ( space-x, space-y )
자식 요소 사이의 공간을 제어하기 위한 유틸리티.

space-x-{amount} 유틸리티를 사용하여 요소 사이의 수평공간(x축)을 제어한다.
ex) space-x-2
space-y-{amount} 유틸리티를 사용하여 요소 사이의 수직공관(y축)을 제어한다.
ex) space-y-4
참조
https://tailwindcss.com/docs/space#add-vertical-space-between-children



#################
### 5.8 Chats ###
#################
-Divide Width
엘리먼트 사이의 border width를 제어하기 위한 유틸리디
divide-x => border-right-width: 1px; border-left-width: 0px;
divide-x-2 => border-right-width: 2px; border-left-width: 0px;

divide-y => border-top-width: 0px; border-bottom-width: 1px;
divide-y-2 => border-top-width: 0px; border-bottom-width: 2px;
참조
https://tailwindcss.com/docs/divide-width



#######################
### 5.9 Chat Detail ###
#######################
-Top/Right/Bottom/left
positioned된 요소의 배치를 제어하기 위한 유틸리티

ex) inset-x-0 => left: 0px; right: 0px;
    inset-x-2 => left: 0.5rem; /* 8px */ right: 0.5rem; /* 8px */

    inset-y-0 => top: 0px; bottom: 0px;
    inset-y-2 => top: 0.5rem; /* 8px */ bottom: 0.5rem; /* 8px */
참조
https://tailwindcss.com/docs/top-right-bottom-left



####################
### 5.13 Streams ###
####################
-Aspect Ratio
요소의 종횡비를 제어하기 위한 유틸리티
또는 대괄호를 사용하여 새로운 속성을 생성할 수 있다.

ex) aspect-auto => aspect-ratio: auot;
    aspect-square => aspect-ratio: 1/1;
    aspect-video => aspect-ratio: 16/9;
-aspect-ratio CSS
종횡비 CSS속성은 자동 크기 및 기타 레이아웃 기능 계산에 사용되는 상자의 기본 종횡비를 설정한다.
참조
https://tailwindcss.com/docs/aspect-ratio
https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio



###########################
### 5.14 Streams Detail ###
###########################
-overflow scrollbar hide
global.css
body{
    -ms-overflow-style: none;
}
::-webkit-scrollbar {
    display: none;
}
추가한다.



###################################################
### 5.16 Layout part One - 5.17 Layout part Two ###
###################################################
-Max-Width
요소의 최대 너비를 설정하는 유틸리티.
ex) max-w-none => max-width: none;
    max-w-xs => max-width: 20rem; /* 320px */
    max-w-sm => max-width: 24rem; /* 384px */
    max-w-md => max-width: 28rem; /* 448px */
    max-w-lg => max-width: 32rem; /* 512px */
    max-w-full => max-width: 100%;
    max-w-screen-sm => max-width: 640px;
    max-w-screen-md => max-width: 768px;
    max-w-screen-lg => max-width: 1024px;
    max-w-screen-xl => max-width: 1280px;
대괄호를 사용하여 임의의 값을 사용하여 즉시 속성을 생성할 수도 있다.
div class="max-w-[50%]"
참조
https://tailwindcss.com/docs/max-width

-Heroicons
https://heroicons.com/

-router.back()
history로 navigate합니다. 브라우저의 뒤로 버튼을 클릭하는 것과 같습니다. window.history.back()을 실행한다.
참조
https://nextjs.org/docs/api-reference/next/router#routerback

-router.push()
클라이언트 측 전환을 처리합니다. 외부 URL에 대해 router.push를 사용할 필요가 없습니다. window.location은 이러한 경우에 더 적합합다.
참조
https://nextjs.org/docs/api-reference/next/router#routerpush



###########################
### 6.1 What is Prisma ###
###########################
-Prisma
Node.js and TypeScript ORM ( Object Relational Mapping )
JS or TS 와 DB 사이에 다리를 놓아줌 ( 번역기 역할을 한다고 생각하면된다. )

Prisma를 사용하기 위해서는 먼저 Prisma에게 DB가 어떻게 생겼는지
데이터의 모양을 설명해야한다.
=> Schema.Prisma

Prisma가 이런 타입에 관한 정보를 알고 있으면 client를 생성해줄 수 있음
client를 이용하면 TS로 DB와 직접 상호작용이 가능하고 자동완성 제공하는

Prisma Studio : Visual Database Browser, DB를 위한 관리자 패널같은 것이다.

Prisma는 개발자가 PostgreSQL, MySQL, SQL Server, SQLite, MongoDB 오픈 소스 데이터베이스 도구를
사용하여 더 빠르게 빌드하고 오류를 줄이는데 도움을 준다
참조
- https://www.prisma.io/



########################
### 6.2 Prisma Setup ###
########################
-Prisma 설치
1. npm i prisma -D
2. npx prisma init
이 명령은 schema.prisma라는 파일과 프로젝트 루트에 .env파일을 포함하여 prisma라는 새 디렉토리를 생성한다.
schema.prisma는 데이터베이스 연결과 Prisma Client 생성기가 있는 Prisma 스키마를 포함한다.
.env는 환경 변수를 정의하기 위한 dotenv 파일이다.( DB를 연결할 때 사용된다. )
schema.prisma 파일에서
ex) datasource db {
        provider = "mysql"
        url      = env("DATABASE_URL")
    }
    provider를 사용할 DB로 바꿔야한다.

-참조
https://www.prisma.io/docs/getting-started/setup-prisma/start-from-scratch/relational-databases-typescript-mysql
-Prisma Model 예시
https://www.prisma.io/docs/concepts/components/prisma-schema
-VSCode Prisma Extension
https://marketplace.visualstudio.com/items?itemName=Prisma.prisma



###############################
### 6.3 What is PlanetScale ###
###############################
-PlanetScale
MySQL호환 Serverless 데이버베이스 플랫폼
https://planetscale.com/

-Vitess
Vitess는 MySQL을 스케일링하기 위한 데이터베이스 클러스터링 시스템의
인터넷에서 가장 큰 사이트를 호스팅하는 강력한 오픈 소스 기술이다
https://vitess.io/

Vitess 장점
- 수평 스케일
- 고가용성( 기본 복제본 구성은 예기치 않은 이벤트가 발생시 기본에서 복제본으로 원활한 장애조치를 허용 )
- MySQL호환
- 쿠버네티스 네이티브
- 구체화된 뷰
- 온라인 스키마 마이그레이션



#####################################
### 6.4 Connecting to PlanetScale ###
#####################################
-PlanetScale CLI
PlanetScale은 데이터베이스 이상이며 CLI는 복잡한 명령 이상이다.
pscale 커맨드 라인을 사용하여 branch, deploy요청 및 기타 PlanetScale 개념을 손쉽게 사용할 수 있다.
참조
https://github.com/planetscale/cli

PlanetScale CLI 설치(윈도우)
1.Scoop설치 (윈도우용 커맨드 라인 설치 프로그램)
- https://scoop.sh/
2.scoop bucket add pscale https://github.com/planetscale/scoop-bucket.git
3.scoop install pscale mysql
4.scoop update pscale

PlanetScale CLI를 사용하여 데이터베이스
생성
pscale database create ## DB NAME ## --region ap-northeast
연결
pscale connect carrot-market
⭐커맨드창을 종료하면 안된다.

연결시 나오는 URL을 .env 파일에 적용하기
ex) DATABASE_URL="mysql://127.0.0.1.@@@@/DB NAME"

PlanetScale 인증
pscale auth login



###############################
### 6.5 Push To PlanetScale ###
###############################
-Prisma Client and schema preview features
Prisma Client 및 Prisma 스키마에 대해 Preview features 플래그를 사용할 수 있다.
참조
https://www.prisma.io/docs/concepts/components/preview-features/client-preview-features\

-Referential integrity (참조 무결성)
어떤 다른 모델을 참조하는 경우 해당 모델이 반드시 존재해야한다.
참조 무결성은 모든 참조가 유효함을 나타내는 데이터 세트의 속성이다.
참조 무결성을 위해서는 한 레코드가 다른 레코드를 참조하는 경우 반드시 해당 참조하는 레코드가 존재해야 한다.
ex) Post모델이 user필드를 정의하는 경우 User(모델)도 반드시 존재해야한다.
참조
https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-integrity

-datasource에서 referential integrity 설정
활성화
schema.prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["referentialIntegrity"]    <-- this.line
}

datasource db {
  provider             = "mysql"
  url                  = env("DATABASE_URL")
  referentialIntegrity = "prisma"               <-- this.line
}
두 라인을 추가해서 활성화해야 참조무결성여부 확인

참조
https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-integrity#setting-the-referential-integrity-in-the-datasource

-db push
db push는 Prisma Migrate와 동일한 엔진을 사용하여 Prisma 스키마를 DB스키마와 동기화하여 스키마 프로토 타이밍에 가장 적합
ex) npx prisma db push

참조
https://www.prisma.io/docs/concepts/components/prisma-migrate/db-push



#########################
### 6.6 Prisma Client ###
#########################
-Prisma Client
TypeScript 및 Node.js용 직관적인 데이터베이스 클라이언트
Prisma Client는 생각하는 방식으로 구성하고 앱에 맞춤화된 유형으로 Prisma스키마에서 자동 생성되는 쿼리 빌더이다.
직관적인 API로 설계되어있다.

npm install prisma --save-dev
npx prisma

npm install @prisma/client
ex) import { PrismaClient } from '@prisma/client'
    const prisma = new PrismaClient()

    const newUser = awaut prisma.user.create({
        data:{
            email: "hi@naver.com",
            name" "hello",
        }
    })

❗ Prisma Client는 프론트엔드에서는 보안문제로 작동하지 않고 서버에서만 사용할 수 있다. ❗



######################
### 6.7 API Routes ###
######################
-API Routes
API Routes는 NextJS로 API를 빌드하기 위한 솔루션을 제공한다.
pages/api 폴더 내의 모든 파일은 /api/*에 매핑되며 API endpoint로 처리됩니다.
sever-side 전용 번들이며 client-side번들 크기를 늘리지 않는다.

req: http.IncomingMessage의 인스턴스와 pre-built된 일부 미들웨어
res: http.ServerResponse의 인스턴스와 일부 helper함수
ex) 다음 API 경로 pages/api/user.js는 상태 코드가 200인 json 응답을 반환합니다.
    export default function handler(
        req: NextApiRequest, 
        res: NextApiResponse,
    ){
        res.status(200).json({ name : 'John Doe' })
    }
참조
https://nextjs.org/docs/api-routes/introduction



############################################
### 7.0 Introduction ( React Hook Form ) ###
############################################
-React Hook Form
사용하기 쉬운 유효성 검사를 통해 성능이 뛰어나고 유연하며 확장 가능한 form이다
참조
https://react-hook-form.com/



##############################
### 7.1 Making Forms Alone ###
##############################
-React Hook Form설치
현재 react18 rc 버전 
npm i react-hook-form --legacy-peer-deps

react18 정식 출시 후 react hook form도 업데이트 완료시
npm i react-hook-form

참조
https://react-hook-form.com/get-started
https://www.npmjs.com/package/react-hook-form



#################################
### 7.2 The Register Function ###
#################################
-Register
register:(name: string, RegisterOptions?) => ({onChange, onBlur, name, ref})
이 메소드를 사용하면 input을 등록하거나 엘리먼트를 선택하고 React Hook Form에 유효성 검사 규칙을 적용할 수 있다.
유효성 검사 규칙은 모두 HTML표준을 기반으로 하며 사용자 지정 유효성 검사 방법도 허용한다.
ex) import { useForm } from 'react-hook-form';
    const { register, handleSubmit } = useForm();

    <input 
        {...register("firstName", {required : true })}
        placeholder="First Name"
    />
참조
https://react-hook-form.com/api/useform/register



################################################
### 7.3 Validation - 7.4 Validation part Two ###
################################################
-register 옵션
required : string | { value : boolean, message : string }
minLength : number | { value : number, message : string }
ex) <input 
        {...register("test",{
            required : 'erroe message;,
        })}
    />
    <input 
        {...register("test",{
            minLength:{
                message : "5자이하입니다.",
                value : 5,
            }
        })}
    />
참조
https://react-hook-form.com/api/useform/register

-handleSubmit
이 함수는 form 유효성 검사가 성공하면 form 데이터를 수신한다.
ex) form onSubmit={ handleSubmit( onSubmit, onError ) }

onSubmit( SubmitHandler ) <-- 성공시 콜백
(data : Object, e?: Event ) => void

onError( SubmitErrorHandler ) <-- 에러 콜백
(errors : Object, e?: Event ) => void
참조
https://react-hook-form.com/api/useform/handlesubmit



##################
### 7.5 Errors ###
##################
-validate
유효성을 검사할 인수로 콜백 함수를 전달하거나 콜백 함수의 개체를 전달하며 모든 유효성을 검사할 수 있다.
ex) <input
        {...register("test", {
            validate : value => value === '1'
        })}
    />
ex2)<input
        {...register("email", {
            required : "Email is required",
            validate : {
                checkGamil : (value) => !value.inclueds("@gmail.com") ? "" : "Gmail is not allowed",
            }
        })}  
    />
참조
https://react-hook-form.com/api/useform/register/

-mode
mode: onChange | onBlur | onSubmit | onTouched | all = 'onSubmit'
이 옵션을 사용하면 사용자가 form을 제출하기 전에 유효성 검사를 할 수 있다.
onTouched
유효성 검사는 첫 번째 blur 이벤트에서 트리거됩니다. 그 후에는 모든 change 이벤트에서 트리거됩니다.
all
blur 및 change 이벤트에서 유효성 검사가 트리거됩니다.
참조
https://react-hook-form.com/api/useform#props



##################
### 7.6 Extras ###
##################
-setError()
이 함수를 사용하면 하나 이상의 오류를 수동으로 설정할 수 있다.
ex) setError("username",{
        type:"manual",
        message" "Username Error",
    })
참조
https://react-hook-form.com/api/useform/seterror

-reset()
전체 form state 또는 form state의 일부를 리셋한다.
 form에서 submit후, 전체 input 초기화
 참조
 https://react-hook-form.com/api/useform/reset

 -resetField()
 개별 field state를 재설정한다.
 form에서 submit후, 특정 input만 초기화
 참조
 https://react-hook-form.com/api/useform/resetfield



######################
### 8.0 Enter Form ###
######################
-Type-Only Imports and Exports
import type은 타입 표기와 선언에 사용될 선언만 import, export한다.
런타임에서는 완전히 지워진다.
마찬가지로 export type은 타입 문맥에 사용할 export만 제공 이 또한 TypeScript의 출력물에서 제거됩니다.
Typescript 3.8에 추가된 것으로 정확하게 type만 import, export하도록 명시 할 수 있다.

ex) import type { user } from './hello';
    export type { user };
    import type { UseFormRegisterReturn } from "react-hook-form";
참조
https://www.typescriptlang.org/ko/docs/handbook/release-notes/typescript-3-8.html



###########################
### 8.1 Form Submission ###
###########################
-Uploading JSON data
POST프로토콜로 JSON인코딩된 데이터를 보내기 위해 fetch()를 사용합니다.
ex) await fetch(url, {
        method: 'POST', // or 'PUT'
        body: JSON.stringify(data), // data can be `string` or {object}!
        headers:{
            'Content-Type': 'application/json'
        }
    })
참조
https://developer.mozilla.org/ko/docs/Web/API/Fetch_API/Using_Fetch#uploading_json_data



#######################
### 8.4 withHandler ###
#######################
-HTTP 상태코드
200 OK : 요청 성공
400 Bad Request : 이 응답은 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미 ( Client가 Request할 때 발생한 문제 )
403 Forbidden : Client는 콘텐츠에 접근할 권리를 가지고 있지 않습니다. 401과 다른 점은 Server가 Client가 누구인지 알고 있다.
405 Method Not Allowed : 요청한 메소드를 Server에서 알고 있지만, 제거되었고 사용할 수 없다. ( 허용되지않은 메소드 사용 )
500 Internal Server Error : Server가 처리 방법을 모르는 상황이 발생. 서버는 아직 처리 방법을 알 수 없습니다.
참조
https://developer.mozilla.org/ko/docs/Web/HTTP/Status

-고차함수 HOF(Higher Order Function)
하나 이상의 함수를 인자로 받고, 결과로 함수를 리턴한다.
다시 말해 함수가 또 하나의 함수를 다루는 함수이다.
HOF를 이용해서 JS에서 함수형 프로그래밍을 다룰 수 있습니다.

// 함수가 또 다른 함수를 리턴하는 구조
ex) const add = function(x) {
        return function(y) {
        return x+y;
        }
    }
    const sum = add(2)(3); // 5
참조
https://javascript-1.gitbook.io/javascript/hof-higher-order-function



#################
### 8.5 Paths ###
#################
-baseUrl
기본 디렉토리를 설정 할 수 있다. ( 루트 폴더를 정의 )
이 프로젝트 내에서 "baseUrl" : "."을 사용한 TS는 tsconfig.json과 동일한 폴더에서 시작하는 파일을 찾는다.
"../" 또는 "./"로 파일을 import해오는 것이 지겹다면 이 문제를 해결할 수 있는 좋은 방법이다.
참조
https://www.typescriptlang.org/tsconfig#baseUrl

-paths
파일을 import해오는 경로를 다시 매핑한다.
이 패턴은 코드베이스 내에서 긴 상대 경로를 피하는데 사용할 수 있다.
ex) "paths": {
        "app/*": ["app/*"],
        "config/*": ["app/_config/*"],
        "environment/*": ["environments/*"],
        "shared/*": ["app/_shared/*"],
        "helpers/*": ["helpers/*"],
        "tests/*": ["tests/*"],
        ↓↓↓ ↓내 프로젝트에서 예시 사용법
        "@libs/*":["libs/*"],
        "@components/*":["components/*"]
    },
참조
https://www.typescriptlang.org/tsconfig#paths

tsconfig 설정 옵션
https://www.typescriptlang.org/tsconfig



##########################
### 9.1 Accounts Logic ###
##########################
-Update or Create Records ( upsert )
upsert()는 기존 데이터를 업데이트하거나 새 데이터베이스 레코드를 생성한다.
ex_1) 
다음 쿼리는  upsert를 사용하여 특정 이메일 주소로 사용자 레코드를 업데이트 하거나, 
존재하지 않을 경우 해당 사용자의 레코드를 생성한다.
const upsertUser = await prisma.user.upsert({
    where: {
    email: 'hello@gmail.com',
    },
    update: {
    name: 'pizza',
    },
    create: {
    email: 'hello@gmail.com',
    name: 'pizza',
    },
})

ex_2)
↓↓↓ ↓내 프로젝트에서 사용법 /api/users/enter
const user = await client.user.upsert({
    where : {
        ...enterType,
    },
    create : {
        name: "@@@",
        ...enterType,
    },
    update : {

    },
})
참조
https://www.prisma.io/docs/concepts/components/prisma-client/crud#update-or-create-records
https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#upsert



#######################
### 9.2 Token Logic ###
#######################
-connect
connect 쿼리는 ID 또는 고유 식별자를 지정하여 레코드를 기존 relation 레코드에 연결한다. ( 레코드를 연결 )
참조
https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#connect

-conncetOrCreate
conncetOrCreate는 ID 또는 고유 식별자로 기존 관련 레코드에 레코드를 연결하거나 레코드가 존재하지 않는 경우 새 관련 레코드를 생성
ex_1) 
tag: {
    conncetOrCreate:{
        create:{
            name: 'ABCD',
        },
        where: {
            name: 'ABCD',
        },
    },
},
ex_2) 
↓↓↓↓ 내 프로젝트에서 사용법 /api/users/enter
const token = await client.token.create({
    data: {
        payload,
        user: {
            connectOrCreate: {
                where: {
                    ...enterType,
                },
                create: {
                    name: "user1",
                    ...enterType,
                },
            },
        },
    },
});
참조
https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#connectorcreate



#######################
### 9.3 Twilo Setup ###
#######################
-Twilio
Twilio는 전화 걸기 및 받기, 문자 메시지 보내기 및 받기, 웹 서비스 API를 사용하여 기타 커뮤니케이션 기능 수행을 위한
프로그래밍 가능한 커뮤니케이션 도구를 제공한다.
참조
https://www.twilio.com/
Twilo Document
https://www.twilio.com/docs



#######################
### 9.4 Sending SMS ###
#######################
-twilio 설치
npm i twilio
Twilio의 메시징 채널을 사용하여 전송된 모든 메시징은 A2P( Application-to-Person ) 메시징으로 취급되며
Twilio의 메시징 정책이 적용된다.
몇 줄의 코드로 Node.js 어플리케이션에서 Twilio Programmable SMS로 문자 메시지를 보내고 받을 수 있다.
ex) 
import twilio from "twilio";
const twilioClient = twilio(
    process.env.TWILIO_SID, process.env.TWILIO_TOKEN
);

twilioClient.messages.create({
    messagingServiceSid: process.env.TWILIO_MSID,
    to: process.env.TWILIO_MY_PHONE!,
    body: `Here is message content`,
});

.env 환경변수
TWILIO_SID=
TWILIO_TOKEN=
TWILIO_MSID=
TWILIO_MY_PHONE= ex) +821012345678  +국가번호가 있어야한다.

참조
https://www.twilio.com/docs/sms/quickstart/node



#########################
### 9.5 Sending Email ###
#########################
-SendGrid
SendGrid는 거래 및 마케팅 이메일을 위한 고객 커뮤니케이션 플랫폼.
https://sendgrid.com/solutions/email-api/

SendGrid를 사용하여 메일 보내기
1. 가입 및 인증 후 API키 생성 및 생성한 API키 환경변수에 저장
2. npm install --save @sendgrid/mail
3. 이메일 보내기 라이브러리 사용
ex) import mail from "@sendgrid/mail";
    
    mail.setApiKey(process.env.SENDGRID_API_KEY!);
    
    const msg = await mail.send({
        from: "from email address",
        to: "to email address",
        subject: "subject",
        text: "text",
        html: "<strong>sendgrid</strong>",
    });
참조
https://app.sendgrid.com/guide/integrate/langs/nodejs



####################
### 9.6 Token UI ###
####################
-BigInt ( JavaScript 타입 )
BigInt는 Number 원시 값이 안정적으로 나타낼 수 있는 최대치인 2^53 -1 보다 큰 정수를 표현할 수 있는 내장 객체이다.
참조
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt

-onDelete: Cascade
schema.prisma
부모 레코드가 삭제되면 자식 레코드를 함께 삭제하도록하는 옵션이다.

// option
Casecade
Restrict
NoAction
SetNull
SetDefault
참조
https://www.prisma.io/docs/concepts/components/prisma-schema/relations/referential-actions



###############################
### 9.7 Serverless Sessions ###
###############################
-Iron Session
데이터를 저장하기 위해 서명되고 암호화된 쿠키를 사용하는 Node.js stateless session 유틸리티
Next.js Express, NestJs, Fastify 및 모든 Node.js HTTP 프레임워크와 함께 작동한다.
설치
npm install iron-session
ex)
import { withIronSessionApiRoute } from "iron-session/next";

export default withIronSessionApiRoute(NextApiHandler)
참조
https://github.com/vvo/iron-session

-req.session.save()
세션 데이터를 암호화하고 쿠리를 설정한다.



###########################
### 9.8 Profile Handler ###
###########################
-TypeScript로 세션 데이터 Tying( req.session에 데이터 연결 )
req.session은 자동으로 올바른 유형으로 채워지므로 .save() 및 .destroy()를 호출할 수 있다.
그러나 더 나아가 세션 데이터도 입력할 수 있다.
ex)
declare module "iron-session"{
    interface IronSessionData {
        user?:{
            id: nuber;,
        };
    }
}
참조
https://github.com/vvo/iron-session#typing-session-data-with-typescript

Module Augmentation
위의 예시와 같이 모듈을 가져와서 module augmentation을 사용해서 컴파일러에게 알려줄 수 있다.
JavaScript 모듈은 병합을 지원하지 않지만 기존 개체를 가져온 다음 업데이트하며 패치할 수 있다.

ex)
import { Observable } from "./observable";
    declare module "./observable" {
        interface Observable< T> {
        map< U>(f: (x: T) => U): Observable< U>;
    }
}
참조
https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation



#####################
### 9.10 NextAuth ###
#####################
-NextAuth.js
Next.js에서 Authentication구현을 도와주는 패키지이다.
NextAuth.js는 Next.js 애플리케이션을 위한 완전한 오픈 소스 인증 솔루션이다.
Next.js 및 Serverless를 지원하도록 처음부터 설계되었다.
참조
https://next-auth.js.org/getting-started/example
https://www.npmjs.com/package/next-auth



#########################
### 10.0 Introduction ###
#########################
-SWR
데이터 fetching 위한 React Hooks
SWR은 먼저 캐시(스태일)로 부터 데이터를 반환한 후, fetch 요청(재검증)을 하고, 최종적으로 최신화된 데이터를 가져오는 방식이다.
SWR을 사용하면 컴포넌트는 지속적이며 자동으로 데이터 업데이트 스트림을 받게 됩니다.
그리고 UI는 항상 빠르고 반응적이다.
참조
https://swr.vercel.app/ko



#########################
### 10.2 useUser Hook ###
#########################
-router.push()
이전 페이지에 대한 히스토리를 남기고 싶다면 router.push()를 사용한다.

-router.replace()
이전 페이지에 대한 히스토리를 남기고 싶지 않다면 roter.replace()를 사용한다.

ex) router.push(url, as, options)
    router.replace(url, as, option)
참조
https://nextjs.org/docs/api-reference/next/router#routerpush



################
### 10.3 SWR ###
################
-SWR
SWR은 먼저 캐시로부터 데이터를 반환한 후, fetch요청(재검증)을 하고, 최종적으로 최신화된 데이터를 가져오는 방식이다.
SWR을 사용하면 컴포넌트는 지속이며 자동으로 데이터 업데이트 스트림을 받게 된다.
그리고 UI는 항상 빠르고 반응적

설치
npm i swr --legacy-peer-deps ( 뒤 명령어는 react18 정식 이전이기 때문에 )
참조
https://swr.vercel.app/ko/docs/getting-started

-useSWR 사용하기
1.JSON데이터를 사용하는 일반적인 RESTful API라면 먼저 네이티브 fetch의 단순 한 래퍼인 fetcher함수를 생성해야한다.
ex) const fetcher = (...args) => fetch(...args).then((response) => response.json());

2.그 다음 useSWR을 import하고 함수 컴포넌트 내에서 사용한다.
ex) const { data, error } = useSWR("/api/users/me", fetcher);
일반적으로 세가지 요청 상태가 가능하다.
loading, ready, error, data 와 error값을 사용해 현재 요청의 상태를 알아내고, 해당하는 UI를 반환할 수 있다.



#############################
### 10.4 useUser Refactor ###
#############################
-Global Configuration
컨텍스트 SWRConfig는 모든 SWR 훅에 대한 Global Configuration(옵션)을 제공한다.
ex) _app.tsx
<SWRConfig
    value={{
        refreshInterval: 3000,
        fetcher: (resource, init) => fetch(resource, init).then(res => res.json())
    }}
>
</SWRConfig>
참조
https://swr.vercel.app/docs/global-configuration

-useSWR 옵션
const { data, error, isValidating, mutate } = useSWR(key, fetcher, options)
참조
https://swr.vercel.app/docs/options



##########################
### 11.0 Product Model ###
##########################
- 기본 유형 매핑
필드에 사용해야 하는 기본 데이터베이스 유형을 정의
참조
https://www.prisma.io/docs/concepts/components/prisma-schema/data-model#native-types-mapping

MySQL 기본 데이터 베이스 유형
ex) @db.Text, @db.MediumText, @db.LongText
참조
https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#mysql

-Next.js로 PrismaClient를 인스턴스화하기 위한 모범 사례
( ↓↓↓ 아래 경고를 해결하는 효과적인 방법 ↓↓↓ )
❗ warn(prisma-client) There are already 10 instances of Prisma Client actively running.
참조
https://www.prisma.io/docs/support/help-articles/nextjs-prisma-client-dev-practices



#############################
### 11.5 Related Products ###
#############################
-OR
하나 이상의 조건이 true를 반환해야한다.
ex) title 필드에 Prisma 또는 DB가 포함된 Post 레코드 가져오기
const result = await prisma.post.findMany({
  where: {
    OR: [
      {
        title: {
          contains: 'Prisma',
        },
      },
      {
        title: {
          contains: 'databases',
        },
      },
    ],
  },
});
참조
https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#or

-AND
모든 조건이 true를 반환해야한다.
ex)
const result = await prisma.post.findMany({
  where: {
    AND: [
      {
        content: {
          contains: 'Prisma',
        },
      },
      {
        published: {
          equals: false,
        },
      },
    ],
  },
});
참조
https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#and

-ORDER BY 및 TAKE
ex)
await prisma.product.findMany({ 
    where: { 
        OR: orArray, 
        AND: { 
            NOT: { 
                id: foundProduct?.id 
            },
        },
    }, 
    orderBy: { 
        createdAt: "desc" 
    }, 
    take: 10 
});



##############################
### 11.6 Favorite Products ###
##############################
-Delete
delete는 기존 DB 레코드를 삭제한다.( id 또는 유니크한 속성으로만 삭제 가능 )
ex) const user = await client.user.delete({
        where: {
            id: 1,
        },
    });
참조
https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#delete

-DeleteMany
deleteMany는 트랜잭션에서 여러 레코드를 삭제한다.
ex) const deleteUser = await client.user.deleteMany({
        where: {
            name: 'iPhone',
        },
    });
참조
https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#deletemany



############################
### 11.8 Bound Mutations ###
############################
-Mutate
mutate(data?, shouldRevalidate?)
캐시 된 데이터를 뮤데이트하기 위한 함수

ex) const { data, mutate } = useSWR<ItemDetailResponse>(router.query.id ? `/api/products/${router.query.id}` : null);
    if (!data) return;
    mutate({ ...data, isLiked: !data?.isLiked }, false);

mutate(data, option)
useSWR로 가져온 data를 뮤테이트, option은 true일 경우 다시 뮤테이트 false일 경우 x
참조
https://swr.vercel.app/ko/docs/mutation

-Bound Mutate
useSWR에 의해 반환된 SWR 객체는 SWR의 키로 미리 바인딩 된 mutate() 함수도 포함된다.
기능적으로는 전역 mutate 함수와 동일하지만 key파라미터를 요구하지 않는다.
ex) const { data, mutate } = useSWR('/api/user', fetcher)
참조
https://swr.vercel.app/docs/mutation#bound-mutate



##############################
### 11.9 Unbound Mutations ###
##############################
-Mutation
useSWRConfig() hook으로부터 mutate 함수를 얻을 수 있으며, mutate(key)를 호출하여 동일한 키를 사용하는
다른 SWR hook에게 revalidation 메시지를 전역으로 브로드캐스팅할 수 있다.
mutate를 사용하면 로컬 데이터를 업데이트하는 동시에 유효성을 다시 검사하고 최종적으로 데이터를 바꿀 수 있다.

ex) const { mutate } = useSWRConfig();

↓↓↓ 이 키가 있는 모든 SWR에 revalidation하도록 지시 및 로컬 데이터가 올바른지 확인하기 위해 갱신( refetch )트리가
mutate(key);
mutate("/api/user");

↓↓↓ 로컬 데이터를 즉시 업데이트하지만, revalitation은 비활성화
mutate("/api/user", {...data, name: newName }, false );

⭐ Bound Mutations = 현재 화면에서 캐시 된 데이터를 mutate 
⭐ Unbound Mutations = mutate(key)를 통해 동일한 키를 사용하는 다른 페이지의 SWR hook을 mutate

참조
https://swr.vercel.app/docs/mutation



####################################
### 11.10 Counting Relationships ###
####################################
-Count relations
relation의 수 (ex: 사용자의 게시글 수, 좋아요 수)를 반환하려면 다음과 같이 중첩 select와 함께
_count 매개변수를 사용한다.
레코드를 반환하는 모든 쿼리와 함께 사용할 수 있다. ( delete, update 및 findFirst 포함 )

ex) const products = await client.product.findMany({
        select: {
            _count: {
                select: {
                    favs: true,
                },
            },
        },
    });
참조
https://www.prisma.io/docs/concepts/components/prisma-client/aggregation-grouping-summarizing#count-relations



######################
### 12.6 useCoords ###
######################
-Geolocation API
사용자의 현재 위치를 지도에 표시하거나 위치 기반 개인화 정보를 제공하는 등 웹, 앱에서 위치 정보를 가져와야하는 경우 사용한다.
Geolocation API는 navigator.geolocation을 통해 접근한다.
이 때 사용자의 브라우저는 위치 정보 접근 권한을 요청하게 되고, 사용자가 허가할 경우 현재 장치에서 사용 가능한 최선의 방법( GPS, WiFi... )을 통해 위치를 알아낸다.

Geolocation.getCurrentPosition()
장치의 현재 위치를 조사한 후 GeolocationPosition 객체로 반환한다.
ex) navigator.geolocation.getCurrentPosition( success, error, [options]);

success
GeolocationPosition 객체를 유일한 매개변수로 받은 콜백 함수.
error: Optional
GeolocationPositionError 객체를 유일한 매개변수로 받은 콜백 함수
참조
https://developer.mozilla.org/ko/docs/Web/API/Geolocation/getCurrentPosition



########################
### 12.7 Geo Search  ###
########################
-gte or lte
get: 크거나 같다.
lte: 작거나 같다.
ex) const getPost = await client.post.findMany({
        where: {
            likes: {
                lte: 9,
            },
        },
    });
참조
https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#lte



###################
### 13.0 Models ###
###################
-@relation 인자
name: 관계를 명확하게 하기 위해 관계의 이름을 정의한다.
@relation(name: "writtenReviews", reference: [id]) 또는 @relation("writtenReviews")
fields: 현재 모델의 필드 목록
reference: 관계의 반대편에 있는 모델의 필드 목록

ex) Review에서 User를 relation하는 경우에 2가지 일경우 name 값을 줘서 관계를 명확하게한다.
model User {
    id              Int         @id @default(autoincrement())
    .
    .
    .
    writtenReviews  Review[]    @relation(name: "writtenReviews")
    receivedReviews Review[]    @relation(name: "receivedReviews")
}

model Review {
  id           Int      @id @default(autoincrement())
  review       String   @db.MediumText
  createdBy    User     @relation(name: "writtenReviews", fields: [createdById], references: [id], onDelete: Cascade)
  createdById  Int
  createdFor   User     @relation(name: "receivedReviews", fields: [createdForId], references: [id], onDelete: Cascade)
  createdForId Int
}
참조
https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#relation

-Disambiguating relations( 명확한 관계 )
두 개의 동일한 모델 간에 두 개의 관계를 정의할 때 @relation속성에 name인수를 추가하여 모호성을 제거해야한다.
참조
https://www.prisma.io/docs/concepts/components/prisma-schema/relations#the-relation-attribute

-enum
enum은 MySQL, PostgreSQL에서 지원
두 가지의 가능한 값으로 enum을 지정하고 기본값으로 설정한다.

ex) 필드값이 동일한 모델을 enum 처리할 경우
model Sale {
    id        Int      @id @default(autoincrement())
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId    Int
    product   Product  @relation(fields: [productID], references: [id], onDelete: Cascade)
    productID Int
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Purchase {
    id        Int      @id @default(autoincrement())
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId    Int
    product   Product  @relation(fields: [productID], references: [id], onDelete: Cascade)
    productID Int
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

                        ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓                         
model User {
    id              Int         @id @default(autoincrement())
    .
    .
    .
    records         Record[]
}

model Record {
    id        Int      @id @default(autoincrement())
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId    Int
    product   Product  @relation(fields: [productID], references: [id], onDelete: Cascade)
    productID Int
    kind      Kind      ⭐⭐⭐
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

enum Kind {
    Sale
    Purchase
}

참조
https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#enum



####################
### 13.1 Reviews ###
####################
-@default
필드의 기본값을 정의한다.
ex) model Post{
        id          Int         @id @default(autoincrement())
        createdAt   DateTime    @default(now())
        title       String
        published   Boolean     @default(false)
    }

❗ 기존 model에 컬럼을 추가시(model내에 데이터가 있을경우) 기본값이 필요한 문제가 생길경우
1. DB 리셋 -> 사용❌❌❌

2. 기본값 추가
ex) @default
model Review {
    id           Int      @id @default(autoincrement())
    score        Int      @default(1) ⭐
}

3. 컬럼값을 require로 설정하지 않기
ex) require(?)
model Review {
    id           Int      @id @default(autoincrement())
    score        Int?     ⭐
}



########################
### 14.1 Detail Page ###
########################
-valueAsNumber: boolean
React-hook-form에서 입력한 input을 숫자로 반환한다.
문제가 발생하면 NaN으로 반환
valueAs 프로세스는 유효성 검사 후 발생한다.
ex) register({valueAsNumber : true})

-valueAsDate: boolean
입력한 input을 날짜로 반환한다.
문제가 발생하면 null이 반환
ex) register({valueAsDate : true})
참조
https://react-hook-form.com/kr/api/



##################################
### 14.4 Mutations and Refresh ###
##################################
-useSWR() 옵션
refreshInterval
기본값: refreshInterval = 0
숫자를 설정하면 밀리초 간격으로 poling 한다.
함수로 설정하면 함수는 최신 데이터를 받고, 밀리초 단위로 리턴한다.
ex) useSWR(`/api/example`, fetcher, { refreshInterval: 1000 })
참조
https://swr.vercel.app/docs/options#options
https://swr.vercel.app/ko/docs/options

Revalidate on Interval
https://swr.vercel.app/docs/revalidation#revalidate-on-interval



####################
### 14.5 Seeding ###
####################
-Seeding ur DB
시딩을 사용하면 DB에 동일한 데이터를 일관되게 다시 생성할 수 있으며 다음을 수행할 수 있다.
1. 어플리케이션을 시작하는데 필요한 데이터(ex: 기본 언어or기본 통화)로 DB를 채운다.
2. 개발 환경에서 어플리케이션을 검증하고 사용하기 위한 기본 데이터 제공.

npm i ts-node
DB에 시드하려면 db seed CLI명령을 실행.
npx prisma db seed
ex) package.json
    "prisma": {
    "seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts"
}
참조
https://www.prisma.io/docs/guides/database/seed-database



#########################
### 15.0 Introduction ###
#########################
-Cloudflare
클라우드를 위해 만들어진 전역 네트워크
Cloudflare는 인터넷에 연결하는 모든 것을 안전하고 비밀을 유지하면서 신속하고 안정적으로 연결하도록 설계된 전역 네트워크이다.
Cloudflare Images
대규모로 이미지를 저장, 크기조정, 최적화하는 하나의 API
Cloudflare Images는 이미지 인프라를 구축하고 유지하는 효율적인 솔루션을 제공.
하나의 통합 제품을 이용해 이미지를 대규모로 저장, 크기 조정, 최적화한다.

1. 이미지 저장
아무리 많은 이미지라도 Cloudflare Images에 저장할 수 있다.
2. 이미지 크기 조정 및 최적화
보관 및 크기 조정의 추가 비용 없이 모든 이미지를 조정할 수 있다.
3. 전달
전세계 Cloudflare 데이터 센터에서 이미지를 전달한다.
참조
https://www.cloudflare.com/ko-kr/products/cloudflare-images/



##########################
### 15.1 Image Preview ###
##########################
-URL.createObjectURL()
URL.createObjectURL(object) 메소드는 주어직 객체를 가리키는 URL을 DOMString으로 반환한다.
같은 객체를 사용하더라도, createObjectURL()을 매번 호출할 때마다 새로운 객체 URL을 생성한다.
각각의 URL을 더는 쓰지 않을 땐 URL.revokeObjectURL()을 사용해 하나씩 해제해줘야한다.
ex) const url = URL.createObjectURL(object)
object
객체 URL을 생성할 File, Blob, MediaSource 객체
리턴값
지정한 object의 참조 URL을 담은 DOMString

참조
https://developer.mozilla.org/ko/docs/Web/API/URL/createObjectURL



###################################
### 15.2 Direct Creator Uploads ###
###################################
-Direct Creator Upload
유저의 브라우저가 cloudflare에 다이렉트로 파일을 업로드할 수 있다.
Cloudflare 이미지의 Direct Creator Upload 기능을 사용하면 사용자가 일회성 업로드 URL로 사진을 업로드할 수 있다.
Direct Creator Upload를 사용하면 API Key 또는 토큰을 클라이언트에 노출하지 않고 업로드들 수락할 수 있다.
또한 중간에 스토리지 버킷 및 이와 관련된 스토리지/송신 비용이 필요하지 않다.

방식1.  ❌
             file                        file
client ----------------> server ----------------> cloudflare
이럴 경우 데이터 전송에 비용 처리가 늘어난다.

방식2 DCU (Direct Creator Upload )  ⭕
             file
client ----------------> cloudflare
cloudflare의 일회성 URL을 통해 다이렉트로 cloudflare에 업로드할 수 있다.
API key 또는 토큰의 노출도 없다.

ex)
curl --request POST \
 --url https://api.cloudflare.com/client/v4/accounts/<ACCOUNT_ID>/images/v2/direct_upload \
 --header 'Authorization: Bearer :token' \
 --form 'requireSignedURLs=true' \
 --form 'metadata={"key":"value"}'

참조
https://developers.cloudflare.com/images/cloudflare-images/upload-images/direct-creator-upload/



#############################
### 15.3 Cloudflare Setup ###
#############################
-Cloudflare Setup
.env
CLOUDFLARE_API_TOKEN=
CLOUDFLARE_ACCOUNT_ID=



##############################
### 15.4 Direct Upload URL ###
##############################
-Direct Upload Endpont
fetch url : `https://api.cloudflare.com/client/v4/accounts/${process.env.CLOUDFLARE_ACCOUNT_ID}/images/v1/direct_upload`

Header
    method: "POST",
    headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${process.env.CLOUDFLARE_API_TOKEN}`,
    },



##############################
### 15.5 Cloudflare Upload ###
##############################
-FormData
Ajax로 form 전송을 가능하게 해주는 FormData 객체를 생성한다.
Ajax는 submit시 기본 폼 동작이 e.preventDefault()이기 때문에, 페이지 전환없이 폼 데이터를 전송할 수 있다.
ex) const form = new FormData() 로 FormData 객체 생성

form.append()를 통해 key, value형태로 값을 추가한다.( form에 일종의 input데이터를 추가한다는 의미 )
form 객체 안에 이미 키가 존재하면 그 키에 새로운 값을 추가하고, 키가 없으면 추가한다.
ex) form.append(name, value);
file 태그일 경우 form.append(name, value, fileName); fileName 없을 경우 기존 파일명

보통 form태그나 input태그없이 Form을 이용해 데이터를 전송하려고 할 때 FormData를 사용한다.
참조
https://developer.mozilla.org/ko/docs/Web/API/FormData



#########################
### 16.0 Introduction ###
#########################
-Image Component and Image Optimization ( 이미지 컴포넌트 및 최적화 )
Next.js 이미지 컴포넌트인 next/image는 모던 웹용으로 발전된 HTML img 태그의 확장이다.
참조
https://nextjs.org/docs/basic-features/image-optimization



#########################
### 16.1 Local Images ###
#########################
-Local Images ( next/image component )
로컬 이미지를 사용하려면 .jpg .png 또는 .webp 파일을 가져온다.
동적 await import() 또는 require()는 지원되지 않는다.
import는 빌드시 분석할 수 있도록 static 이어야 한다.
Next.js는 가져온 파일을 기반으로 이미지의 너비와 높이를 자동을 결정

<Image
    src={picture}
    alt"this is picture"
    width={500}             자동으로 제공
    height={500}            자동으로 제공
    blurDataURL="data:..."  자동으로 제공
    placeholder="blur"      로딩 중 blur-up(선택)
/>
참조
https://nextjs.org/docs/basic-features/image-optimization#local-images



##########################
### 16.2 Remote Images ###
##########################
-Remote Images
원격 이미지를 사용하려면 src속성이 URL 문자열이어야 하며 relative 또는 absolute일 수 있습니다.
Next.js는 빌드 프로세스 동안 원격 파일에 액세스할 수 없으므로 width, height 및 선택적 blurDataURL props을 수동으로 설정해야한다.
참조
https://nextjs.org/docs/basic-features/image-optimization#remote-images

-Domains ( next.config.js 설정 )
Next.js 이미지 최적화 API를 사용하면서 원격 이미지에 접근하고 싶을 경우 loader를 기본 설정으로 두고
src에 대한 절대 URL을 입력한다.
악의적인 사용자로부터 애플리케이션을 보호하려면 이러한 방식으로 접근하려는 원격 도메인 목록을
아래와 같이 next.config.js 파일에 정의해야한다.
ex) next.config.js
module.exports = {
    images: {
        domains: ['imagedelivery.net','example.com', 'example2.com'],
    },
}
참조
https://nextjs.org/docs/basic-features/image-optimization#domains



########################
### 16.3 Layout Fill ###
########################
-layout
뷰포트의 크기가 변경될 때 이미지의 레이아웃 동작

-layout options
intrinsic (default): 이미지의 크기까지 컨테이너 너비에 맞게 축소
fixed: 너비와 높이를 정확하게 사이즈
responsive: 컨테이너 너비에 맞게 크기 조정
fill(width와 height를 주지 않았을 때 줘야하는 속성): 컨테이너를 채우기 위해 x,y 축 모두에 성장
참조
https://nextjs.org/docs/api-reference/next/image#layout

object-fit
CSS object-fit 속성은 img나 video 요소와 같은 대체 요소와 같은 대체 요소의 콘텐츠 크기를
어떤 방식으로 조절해 요소에 맞출 것인지 지정한다.
object-position 속성을 사용해 대체 요소 콘텐츠가 콘텐츠 박스 내에 위치할 지점을 바꿀 수 있다.
참조
https://developer.mozilla.org/ko/docs/Web/CSS/object-fit

+ object-fit을 tailwind로도 줄 수 있지만 
Image컴포넌트에서 제공하는 objectFit="cover"을 통해 줄 수도 있다.

ex) <div class="relative pb-80">
        <Image
            alt="Mountains"
            src="/mountains.jpg"
            layout="fill"
            ogjectFit="cover"
            quality={100}
        />
    </div>



########################
### 19.0 Middlewares ###
########################
-_middleware
미들웨어가 /pages/_middleware.ts에 생성된 경우 /pages 디렉토리 내의 모든 경로에서 실행된다.
▽pages
    _middleware.ts  --> this middleware will run all routes under /pages
    index.tsx
    ...

중첩 경로가 있는 하위 디렉토리가 있는 경우 미들웨어는 위에서 아래로 실행된다.
▽pages
    index.tsx
▽profile
    _middleware.ts --> 첫번째로 실행
    about.tsx
▽chats
    _middleware.ts --> 두번째로 실행
    [id].tsx

참조
https://nextjs.org/docs/advanced-features/middleware#execution-order



#######################################
### 19.1 Responses and Redirections ###
#######################################
-Response
미들웨어는 request가 완료되지 전에 코드를 실핼할 수 있기 때문에 Next.js에서 완전한 유연성을 제공한다.
사용자의 수신 요청에 따라 rewriting, redirecting, 헤더 추가 또는 HTML 스트리밍을 통해 response를 수정할 수 있다.
ex) 
import type { NextRequest, NextFetchEvent } from "next/server";
import { NextResponse } from "next/server";

export function middleware(req: NextRequest, ev: NextFetchEvent) {
    return new Response('this is middleware !!!");
}

참조
Response (MDN)
Fetch API의 response 인터페이스는 요청에 대한 응답을 나타냅니다.
https://developer.mozilla.org/en-US/docs/Web/API/Response



############################
### 19.2 Dynamic Imports ###
############################
-Dynamic Import
Next.js는 JS용 ES2020 Dynamic import()를 지원한다.
이를 통해 JS모듈을 동적으로 가져와서 작업할 수 있다.
또한 SSR과 함께 작동한다. dynamic()은 React.lazy와 유사하게 사전 로드가 작동하도록 모듈의 최상위에 표시되어야 하므로
React랜더링 내부에서 사용할 수 없다.

보통의 경우는 상단에 import를 통해 컴포넌트를 불러온다.
이럴경우 유저는 해당컴포넌트를 사용하지않아도 컴포넌트를 불러오는데
Dynamic Import를 사용 할 경우 사용자가 컴포넌트를 사용할때 불러오게한다.
ex) import dynamic from 'next/dynamic'
    ex: basic
    const DynamicComponent = dynamic(() => import('../component/example'));
    ex: with no SSR
    항상 server side에 모듈을 포함하고 있는건 아니다. 예를 들어 브라우저에서만 작동하는 라이브러리가 포함된 경우라면 ssr : false를 통해 CSR로 실행 할 수 있다.
    const DynamicComponent = dynamic(() => import('../component/example'), { ssr : false });

    <div>
        <DynamicComponent />
    </div>
참조
https://nextjs.org/docs/advanced-features/dynamic-import



##############################
### 19.3 Lazy-load Imports ###
##############################
-With custom loading commponents
dynamic 컴포넌트가 로도되는 동안 로드 상태를 렌더링하기 위해 선택적으로 로딩컴포넌트를 추가 할 수 있다.
ex) const DynamicComponentWithCustomLoading = dynamic(() => import('../components/hello'),
        { loading: () => <span>Loading...</span>}
    );

-With Suspense
Suspense를 사용하면 React.lazy 및 React18의 Suspense와 유사한 컴포넌트를 자연로드(lazy-load)할 수 있다.
fallback이 있는 클라이언트 측 또는 서버 측에서만 작동한다.
ex) const DynamicComponent = dynamic(() => import('../component/example'), { suspense : true });
    < Suspense fallback={`loading...`}>
        <DynamicLazyComponent />
    < /Suspense>
참조
https://nextjs.org/docs/advanced-features/dynamic-import#with-custom-loading-component



################################
### 19.4 _document and Fonts ###
################################
-Custom Document
Custom Document는 페이지를 랜더링하는데 사용되는 html 및 body 태그를 업데이트할 수 있다.
이 파일은 서버에서만 랜더링되므로 onClick과 같은 이벤트 핸들러는 _document에서 사용할 수 없다.
html, Head, Main 및 NextScript는 페이지가 제대로 렌더링되는데 필요하다.
ex) import { Html, Head, Main, NextScript } from 'next/document'

    export default function Document() {
    return (
        <Html>
            <Head />
            <body>
                <Main />
                <NextScript />
            </body>
        </Html>
        )
    }
⭐⭐⭐ Custom Document는 서버에서 한번만 랜더링된다. ⭐⭐⭐
참조
https://nextjs.org/docs/advanced-features/custom-document

Custom Document (Typescript)
https://nextjs.org/docs/advanced-features/custom-document#typescript



#############################
### 19.5 Script Component ###
#############################
-Script Component
Next.js Script 컴포넌트인 next/script는 HMTL script 태그의 확장이다.
이를 통해 개발자는 애플리케이션에서 써드 파티 스크립트의 로드되는 우선 순위를 설정할 수 있으므로 
개발자 시간을 절약하면서 로드하는 성능을 향상시킬 수 있다.

afterInteractive: 페이지가 interactive 된 후에 로드( 기본값 )
beforeInteractive: 페이지가 interactive 되기 전에 로드
lazyOnload: 다른 모든 데이터나 소스를 불러온 후에 로드
worker: web worker에 로드( 실험용? )



###############################
### 19.6 getServerSideProps ###
###############################
-getServerSideProps
페이지에서 getServerSideProps( 서버측 랜더링 )라는 함수를 export경우 Next.js는 getServerSideProps에서
반환된 데이터를 사용하여 각 요청에서 이 페이지를 미리 랜더링한다.

ex) export async function getServerSideProps(){
        return: {
            props: {},
        }
    }
참조
https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props



######################
### 19.7 SSR + SWR ###
######################
-Pre-rendering with Default Data
페이지를 미리 랜더링해야 하는 경우 Next.js는 2가지 형태의 사전 랜더링을 지원한다.
Static Generation(SSG), Server-side-Rendering(SSR)
SWR를 사용하면서, SEO를 위해 페이지를 미리 랜더링할 수 있으며 클라이언트 측에서 caching, revalidation, focus taracking, refetching와 같은 기능도 사용할 수 있다.

ex) export default function Page({ fallback }) {
    //SWRConfig안에 SWR훅은 SWRConfig의 value값을 사용합니다.
    //fallback에는 key-value 객체를 통해 캐시의 초기값을 설정할 수 있습니다.
        return (
        <SWRConfig value={{ fallback }}>
            <Article />
        </SWRConfig>
        )
    }
ex) index.tsx
    const Page: NextPage<ProductsResponse> = ({ products, pages }) => {
        return(
        <SWRConfig
            value={{
            fallback: {
Key-value --->  [unstable_serialize(getKey)]: 
                [
                    {   
                    ok: true,
                    products,
                    pages,
                    },
                ],
            },
            }}
        >
            <Home />
        </SWRConfig>
        )
    };
참조
https://swr.vercel.app/docs/with-nextjs#pre-rendering-with-default-data



#################################
### 19.8 SSR + Authentication ###
#################################
getServerSideProps에는 context라는 데이터가 있다
context 오브젝트의 데이터 타입은 NextPageContext
getServerSideProps를 withSsrSession 함수로 한번 더 감싸서 인증 처리 



#########################
### 19.9 Blog Section ###
#########################
-getStaticProps
페이지에서 getStaticProps( 정적 사이트 생성 )라는 함수를 export하는 경우
Next.js는 getStaticProps에서 반환된 props를 사용하여 빌드시 이 페이지를 미리 랜더링한다.
ex) DB를 거치지 않고 md파일로 페이지를 작성할 때
nomadcoders의 faq 페이지 
https://nomadcoders.co/faq

참조
https://nextjs.org/docs/basic-features/data-fetching/get-static-props



############################
### 19.10 getStaticProps ###
############################
-getStaticProps
getStaticProps는 항상 서버에서 실행되고 클라이언트에서는 실행되지 않는다.
getStaticProps는 정적 HTML을 생성하므로 들어오는 request( ex: 쿼리 매개변수 or HTTP헤더 )에 액세스할 수 없다.
getStaticProps가 있는 페이지가 빌드시 미리 랜더링되면 페이지 HTML파일 외에도 Next.js가 getStaticProps 실행 결과를 포함하는 JSON파일을 생성한다.

readdireSync()
디렉토리(폴더)의 내용을 읽는다

readFileSync()
path의 내용을 반환

참조
https://nextjs.org/docs/basic-features/data-fetching/get-static-props

gray-matter
문자열 또는 파일에서 front-matter을 파싱한다.
npm i gray-matter
https://github.com/jonschlinkert/gray-matter

⭐getServerSideProps : 유저의 요청이 발생할 때마다 일어남
⭐getStaticProps : 페이지가 빌드되 Next.js가 해당 페이지를 export한 후 일반 html로 될때, 딱 한번만 실행된다.



#####################################
### 19.11 getStaticPaths part One ###
#####################################
-미들웨어( _middleware )
중간에 request를 가로챈다.

Server( getInitialProps 또는 getServerSideProps )
런타임시 서버 사이드 랜더링

Static( 초기 props를 사용하지 않음 )
static HTML로 자동으로 랜더링된다.

SSG( getStaticProps )
static HTML + JSON으로 자동으로 생성된다.



#####################################
### 19.12 getStaticPaths part Two ###
#####################################
-getStaticPaths
⭐동적인 라우트( 동적인 URL )을 갖는 페이지에서 getStaticProps를 사용할 때 필요하다. (ex. [slug].tsx)
동적 경로를 사용하는 페이지에서 getStaticPaths( 정적 사이트 생성 )라는 함수를 export할 때 Next.js는 getStaticPaths에 의해
지정된 모든 경로를 정적으로 미리 랜더링한다,
⭐getStaticPaths는 getStaticProps와 함께 사용해야하며 getServerSideProps와 함께 사용할 수 없다.
또한 getStaticPaths는 getStaticProps도 사용하는 동적 경로에서만 export할 수 있다.

ex) [slug].tsx
    export async function getStaticPaths(){
        return {
            paths: [
                params : { slug : "@@@" }       객체에 key 이름은 [slug].tsx 파일에 변수?값이랑 동이해야한다.
            ],
            fallback: true      --> false or 'blocking'
        };
    }
참조
https://nextjs.org/docs/basic-features/data-fetching/get-static-paths



#####################################
### 19.13 Dynamic getStaticProps  ###
#####################################
-matter.read(filepath, options)
파일 시스템에서 파일을 동기적으로 읽고, front matter를 파싱한다.
matter()와 동일한 객체를 반환한다.
filepath에는 읽을 파일의 경로를 지정한다.
ex) const file = matter.read('./posts/@@@@.md');
참조
https://www.npmjs.com/package/gray-matter#read

-remark-html
HTML serializing 지원을 추가하는 remark 플러그인
설치 
$ npm i remark-html remark-parse unified

ex) const file = await unified()
        .use(remarkParse)
        .use(remarkHtml)
        .process(await read('example.md'))
참조
https://www.npmjs.com/package/remark-html



########################
### 19.14 Inner HTML ###
########################
-dangerouslySetInnerHTML
dangerouslySetInnerHTML은 브라우저 DOM에서 innerHTML을 사용하기 위한 React의 대체 방법이다.
일반적으로 코드에서 HTML을 설정하는 것은 사이트간 스크리빙 공격에 쉽게 노출될 수 있기 때문에 위험하다.
따라서 React에서 직접 HTML을 설정할 수는 있지만, 위험하다는 것을 상기시키기 위해 dangerouslySetInnerHTML을 작성하고
__html 키로 객체를 전달해야 한다.
ex) function MyComponent() {
        return < div dangerouslySetInnerHTML={{ __html: "< div>pizza< /div>" }} / >;
    }
참조
https://ko.reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml



###################
### 19.15 Recap ###
###################
getStaticPaths는 언제 사용해야 하는지?
동적 경로를 사용하는 페이지를 정적으로 pre-rendering하는 경우 getStaticPaths를 사용해야한다.
-데이터를 헤드리스 CMS에서 가져올 때
-데이터를 데이터베이스에서 가져올 때
-데이터를 파일 시스템에서 가져올 때
-데이터를 공개적으로 캐시할 수 있을 때
-페이지는 SEO를 위해 pre-rendering되어야 하고 매우 빨라야 할 때
getStaticProps는 성능을 위해 CDN에서 캐시할 수 있는 HTML 및 JSON 파일을 생성한다.
참조
https://nextjs.org/docs/basic-features/data-fetching/get-static-paths#when-should-i-use-getstaticpaths

언제 실행되는지?
getStaticPaths는 프로덕션 환경에서 빌드하는 동안에만 실행되며 런타임에는 호출되지 않는다.
참조
https://nextjs.org/docs/basic-features/data-fetching/get-static-paths#when-does-getstaticpaths-run



#########################
### 20.1 ISR part One ###
#########################
-ISR( Incremental Static Regeneration )
Next.js를 사용하면 사이트를 build한 후 다시 static 페이지를 만들거나 업데이트할 수 있다.
ISR를 사용하면 ⭐전체 사이트를 다시 build할 필요 없이⭐ 각각의 페이지별로 static-Generation을 사용할 수 있다.
ISR을 사용하면 수백만 페이지로 확장하면서 static의 이점을 유지할 수있다.
ISR을 사용하려면 getStaticProps에 revalidate prop을 추가하면된다.

ex) export async function getStaticProps() {
        const res = await fetch('https://.../posts');
        const posts = await res.json();
    return {
        props: {
            posts,
        },
        revalidate: 10, // request가 왔을 때 최대 10초에 한번씩 Next.js는 페이지 re-generate(재생성)을 시도합니다. (10초로 지정함)
        }
    }
참조
https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration